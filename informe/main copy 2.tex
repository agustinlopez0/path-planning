\documentclass{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage[shortlabels]{enumitem}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{listings}
\lstset{
%   backgroundcolor=\color{lightgray}, % color de fondo
  basicstyle=\ttfamily\small, % estilo básico
  breaklines=true, % ajustar línea automáticamente
  frame=single, % marco alrededor del código
  language=C, % lenguaje de programación
  numbers=left, % número de líneas a la izquierda
  numberstyle=\tiny\color{gray}, % estilo de números de línea
  keywordstyle=\color{violet}, % color de palabras clave
%   commentstyle=\color{green}, % color de comentarios
  stringstyle=\color{red}, % color de cadenas
  captionpos=b, % título en la parte inferior
  showstringspaces=false % no mostrar espacios en las cadenas
}
\renewcommand{\footrulewidth}{0.8pt}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}

\pagestyle{fancy}

\newenvironment{problem}[2][Problem]
    { \begin{mdframed}[backgroundcolor=gray!20] \textbf{#1 #2} \\}
    {  \end{mdframed}}

% \fancyfoot[C]{} % Esto elimina la numeración de página en el pie de página

\newenvironment{solution}{\textbf{Solution}}

\lhead{Agustín López}
\rhead{Licenciatura en Ciencias de la Computación} 
\chead{\textbf{}}
\rfoot{FCEIA}

\begin{document}
\input{coverPage}

\section{Actividad 1}

En esta actividad, se presenta el desarrollo e implementación de un algoritmo de navegación para un robot en un entorno desconocido donde el robot se mueve a ciegas y solo puede detectar los obstáculos al ``chocarse'' con ellos. El objetivo es que el robot llegue a la posición objetivo de manera eficiente, evitando obstáculos y explorando nuevas áreas de forma sistemática.

A continuación, se detallan los pasos del algoritmo y estructuras relevantes para su implementación.

\subsection{Descripción del Algoritmo}
\begin{problem}{Algoritmo}
    El algoritmo para la navegación del robot sigue los siguientes pasos:

    \begin{enumerate}
        \item \textbf{Paso 1:} El robot comienza moviéndose en dirección vertical buscando alinearse con la posición objetivo. Cuando el robot logra llegar a la altura del destino o se encuentra con algún obstaculo intenta moverse en dirección horizontal siguiendo el mismo principio. Este proceso se repite en bucle hasta que el robot no pueda acercarse más al objetivo utilizando este método.

        \item \textbf{Paso 2:} Cuando el robot llega a una posición en la que no puede avanzar más, desde su posicion actual se mueve hacia una celda vecina que no haya sido visitada previamente. Este paso asegura que el robot explora nuevas áreas del mapa y evita el movimiento redundante en regiones ya descubiertas. Después, el robot vuelve al paso 1.

        \item \textbf{Paso 3:} Si no hay celdas vecinas no visitadas, el robot retrocede una posición por la ruta previamente recorrida y regresa al paso 1.
    \end{enumerate}

    Este enfoque permite al robot explorar el entorno sin quedar atascado en un bucle infinito y llegar a la posición objetivo de manera eficiente, maximizando la cobertura del área e intentando minimizar el tiempo de búsqueda.
\end{problem}

\subsection{Estructuras de Datos Utilizadas}

\textbf{Estructura \texttt{Robot}:}
Para la implementación del algoritmo, una de las estructuras más importantes es \texttt{Robot}, que representa la información con la que cuenta el robot y que luego utiliza para seguir el algoritmo descripto.

\begin{lstlisting}[language=C]
 typedef struct {
     int i;
     int j;
 } _Punto;
 typedef _Punto* Punto;
 
 typedef enum {
     LEFT, 
     RIGHT,  
     UP,     
     DOWN    
 } Direccion;
 
 typedef struct {
     Punto pos; 
     Punto dest; 
     Pila movimientos; 
     TablaHash visitados;
 } _Robot;
 typedef _Robot *Robot;
\end{lstlisting}

\pagebreak

\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{Punto \texttt{pos} y \texttt{dest}:} Representan la posición actual y la posición destino del robot, respectivamente.

    \item \textbf{Pila \texttt{movimientos}:} Una pila implementada con una lista general simplemente enlazada con un puntero al primer elemento que almacena elementos de tipo \texttt{Direccion*}. Cuando el robot realiza un movimiento en alguna dirección que no sea un retroceso (por ejemplo, hacia la izquierda), se agrega el movimiento a la pila. De este modo, cuando el robot tenga que realizar un retroceso, el movimiento que se ejecute será en la dirección opuesta a la almacenada en el tope de la pila.

    \item \textbf{TablaHash \texttt{visitados}:} Una tabla hash que almacena las posiciones visitadas por el robot. Esta tabla se utiliza para evitar que el robot visite una celda más de una vez (o dos veces si contamos el retroceso) y para determinar si hay celdas sin visitar en el mapa para posteriormente moverse hacia ellas. La elección de la estructura \texttt{TablaHash} se basa en su eficiencia en la búsqueda en tiempo constante teniendo en cuenta que la búsqueda es algo que ocurre muchas veces mientras se ejecuta el algoritmo, y además en el hecho de que durante la ejecución no se necesita eliminar elementos de la tabla.
\end{itemize}


\section{Actividad 2}

En esta actividad el objetivo sigue siendo el mismo que en la actividad anterior, pero en este caso el robot cuenta con un sensor que le permite reconocer si hay o no obstáculos en cierta cantidad de celdas hacia las cuatro direcciones cardinales (arriba, abajo, izquierda, derecha). El robot se desplaza en un mapa representado por una matriz de dimensiones \(N \times M\) que almacena elementos de tipo \texttt{char} y debe llegar a un destino específico desde una posición inicial, evitando obstáculos y utilizando el sensor para obtener información sobre su entorno e intentando optimizar el uso del mismo dado que se considera costoso.

\subsection{Descripción del Algoritmo}
\begin{problem}{Algoritmo}
    El algoritmo para la navegación del robot con sensor sigue los siguientes pasos:

    \begin{enumerate}
        \item \textbf{Paso 0:} En este momento el robot no cuenta con nada de información, por lo que usa el sensor para detectar obstáculos y/o casillas libres a su alrededor.
        
        \item \textbf{Paso 1:} El robot siempre conoce su posicón inicial y la posicion destino, entonces utilizando una implementación basada en el algoritmo A* calcula la ruta mas corta hacia el destino asumiendo que las casillas desconocidas estan libres pero tienen sumado un costo fijo que representa el costo de usar el sensor.

        \item \textbf{Paso 2:} Una vez que se construye el camino óptimo, el robot se mueve a lo largo de él mientras las casillas sean conocidas, si la siguiente casilla del camino es desconocida utiliza el sensor para asegurarse de que no hay un obstáculo y vuelve al paso 1 recalculando la ruta con la nueva información.
    \end{enumerate}

    Este enfoque permite al robot explorar el entorno de manera más eficiente y segura, utilizando la información del sensor para evitar obstáculos y encontrar un camino que quizas no sea el más corto pero intentará usar la menor cantidad de veces posible el sensor.
\end{problem}
\pagebreak
\subsection{Estructuras de Datos Utilizadas}



\begin{lstlisting}[language=C]
typedef struct {
    Punto *pos;
    Punto *dest;
    Mapa *mapa;
    DGList camino;
} _Robot;
typedef _Robot *Robot;

typedef struct {
    Punto padre;
    int costo;
} CeldaInfo;
\end{lstlisting}

\textbf{Estructuras \texttt{Robot} y \texttt{CeldaInfo}:}
Para la implementación del algoritmo, estas son las estructuras centrales que representan información clave al momento de calcular la ruta óptima y que el robot se mueva  a lo largo de ella.
\subsubsection{Robot}
\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{Punto \texttt{*pos} y \texttt{*dest}:} Representan la posición actual y la posición destino del robot, respectivamente al igual que en la actividad 1.

    \item \textbf{Mapa \texttt{*Mapa}:} Representa la información que tiene el robot sobre el mapa actual, es una matriz de char de dimensiones \(N \times M\) donde cada celda puede tener uno de los siguientes valores:
        \begin{enumerate}
            \item \texttt{`?'}: Celda desconocida.
            \item \texttt{`.'}: Celda libre.
            \item \texttt{`\#'}: Celda con obstáculo.
        \end{enumerate}
        Esta matriz se irá actualizando a medida que el robot utilice el sensor y será clave al momento de calcular los costos.

    \item \textbf{DGList \texttt{camino}:} Una lista general simplemente enlazada con un puntero al inicio y otro al final que almacena elementos de tipo \texttt{char*} que son los caracteres que se imprimirán al final del programa para que el sensor interprete si el robot llegó o no a su destino.
    El puntero al inicio es para poder recorrer la lista al momento de imprimir la ruta y el puntero al final es para poder agregar elementos al final de la lista en tiempo constante cada vez que el robot realiza un movimiento.
\end{itemize}

\subsubsection{CeldaInfo}
\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{Punto \texttt{*padre}:} Representa la posición de la celda previa en el camino óptimo hacia esta celda.
    \item \textbf{int \texttt{costo}:} Representa el costo acumulado de llegar a esta celda desde la posición inicial del robot al momento de calcular la ruta.
\end{itemize}

\pagebreak
\subsection{Algunas detalles relevantes para el cálculo y seguimiento de la ruta óptima}

\subsubsection{Cálculo de costos:}
La estructura principal para el cálculo de los costos es la matriz \(N \times M\) de \texttt{CeldaInfo} la cual se inicializa con los valores de costo en \texttt{INT\_MAX} y el puntero a la celda padre como el punto \texttt{(-1, -1)} indicando que no tiene padre. 

Primero, se agrega la posición inicial del robot a la cola de prioridad con costo 0 y se actualiza la matriz de costos con este valor.

Luego, se extraen los elementos de la cola de prioridad y se calculan los costos de las celdas adyacentes de la siguiente manera:

\begin{itemize}
    \item Si la celda adyacente no es un obstáculo, el costo se calcula como:
    \[
    \text{costo}(\text{celda actual}) + 1 + \text{distancia}(\text{celda actual}, \text{destino}).
    \]
    \item Si la celda adyacente es desconocida, el costo es:
    \[
    \text{costo}(\text{celda actual}) + 1 + \text{distancia}(\text{celda actual}, \text{destino}) + C_{\text{sensor}},
    \]
    donde \( C_{\text{sensor}} \) es un valor fijo que representa el costo de usar el sensor.
    \item Si la celda adyacente es un obstáculo, el costo se define como:
    \[
    \text{INT\_MAX},
    \]
    de modo que no se considere en el cálculo de la ruta.
\end{itemize}

Si el nuevo costo es menor al que se tenía almacenado en la matriz de costos, se actualiza el valor y el padre, también se agrega un nodo a la cola de prioridad con el nuevo costo. Este proceso se repite hasta que la cola de prioridad esté vacía o se llegue a la posición destino.

\subsubsection{Seguimiento de la ruta:}

Una vez que se calcula la ruta óptima, el robot simplemente reconstruye la ruta del destino siguiendo al nodo padre de la matriz de \texttt{CeldaInfo} hasta llegar a la posición inicial. De esta forma, se obtiene la ruta óptima que el robot debe seguir para llegar a su destino.

El robot se mueve a lo largo de esta ruta, y si encuentra una celda desconocida utiliza el sensor y vuelve a calcular la ruta óptima con la nueva información, posteriormente se mueve a lo largo de la nueva ruta. Este proceso se repite hasta que el robot llegue a su destino.


\end{document}
