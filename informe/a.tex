\documentclass{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage[shortlabels]{enumitem}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily\small, % estilo básico
  breaklines=true, % ajustar línea automáticamente
  frame=single, % marco alrededor del código
  language=C, % lenguaje de programación
  numbers=left, % número de líneas a la izquierda
  numberstyle=\tiny\color{gray}, % estilo de números de línea
  keywordstyle=\color{violet}, % color de palabras clave
  stringstyle=\color{red}, % color de cadenas
  captionpos=b, % título en la parte inferior
  showstringspaces=false % no mostrar espacios en las cadenas
}
\renewcommand{\footrulewidth}{0.8pt}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}

\pagestyle{fancy}

\newenvironment{problem}[2][Problem]
    { \begin{mdframed}[backgroundcolor=gray!20] \textbf{#1 #2} \\}
    {  \end{mdframed}}

\newenvironment{solution}{\textbf{Solution}}

\lhead{Agustín López}
\rhead{Licenciatura en Ciencias de la Computación} 
\chead{\textbf{}}
\rfoot{FCEIA}

\begin{document}
\input{coverPage}

\section{Actividad 1}

En esta actividad se presenta el desarrollo e implementación de un algoritmo de navegación para un robot en un entorno desconocido, donde el robot se mueve a ciegas y solo puede detectar los obstáculos al ``chocarse'' con ellos. El objetivo es que el robot llegue a la posición objetivo de manera eficiente, evitando obstáculos y explorando nuevas áreas de forma sistemática.

A continuación, se detallan los pasos del algoritmo y las estructuras relevantes para su implementación.

\subsection{Descripción del Algoritmo}
\begin{problem}{Algoritmo}
    El algoritmo para la navegación del robot sigue los siguientes pasos:

    \begin{enumerate}
        \item \textbf{Paso 1:} El robot comienza moviéndose en dirección vertical buscando alinearse con la posición objetivo. Cuando el robot logra llegar a la altura del destino o se encuentra con algún obstáculo, intenta moverse en dirección horizontal siguiendo el mismo principio. Este proceso se repite en bucle hasta que el robot no pueda acercarse más al objetivo utilizando este método.

        \item \textbf{Paso 2:} Cuando el robot llega a una posición en la que no puede avanzar más, desde su posición actual se mueve hacia una celda vecina que no haya sido visitada previamente. Este paso asegura que el robot explore nuevas áreas del mapa y evita el movimiento redundante en regiones ya descubiertas. Después, el robot vuelve al paso 1.

        \item \textbf{Paso 3:} Si no hay celdas vecinas no visitadas, el robot retrocede una posición por la ruta previamente recorrida y regresa al paso 1.
    \end{enumerate}

    Este enfoque permite al robot explorar el entorno sin quedar atascado en un bucle infinito y llegar a la posición objetivo de manera eficiente, maximizando la cobertura del área e intentando minimizar el tiempo de búsqueda.
\end{problem}

\subsection{Estructuras de Datos Utilizadas}

\textbf{Estructura \texttt{Robot}:}
Para la implementación del algoritmo, una de las estructuras más importantes es \texttt{Robot}, que representa la información con la que cuenta el robot y que luego utiliza para seguir el algoritmo descrito.

\begin{lstlisting}[language=C]
 typedef struct {
     int i;
     int j;
 } _Punto;
 typedef _Punto* Punto;
 
 typedef enum {
     LEFT, 
     RIGHT,  
     UP,     
     DOWN    
 } Direccion;
 
 typedef struct {
     Punto pos; 
     Punto dest; 
     Pila movimientos; 
     TablaHash visitados;
 } _Robot;
 typedef _Robot *Robot;
\end{lstlisting}

\pagebreak

\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{Punto \texttt{pos} y \texttt{dest}:} Representan la posición actual y la posición destino del robot, respectivamente.

    \item \textbf{Pila \texttt{movimientos}:} Una pila implementada con una lista general simplemente enlazada con un puntero al primer elemento que almacena elementos de tipo \texttt{Direccion*}. Cuando el robot realiza un movimiento en alguna dirección que no sea un retroceso (por ejemplo, hacia la izquierda), se agrega el movimiento a la pila. De este modo, cuando el robot tenga que realizar un retroceso, el movimiento que se ejecute será en la dirección opuesta a la almacenada en el tope de la pila.

    \item \textbf{TablaHash \texttt{visitados}:} Una tabla hash que almacena las posiciones visitadas por el robot. Esta tabla se utiliza para evitar que el robot visite una celda más de una vez (o dos veces si contamos el retroceso) y para determinar si hay celdas sin visitar en el mapa para posteriormente moverse hacia ellas. La elección de la estructura \texttt{TablaHash} se basa en su eficiencia en la búsqueda en tiempo constante, teniendo en cuenta que la búsqueda es algo que ocurre muchas veces mientras se ejecuta el algoritmo. Además, durante la ejecución no se necesita eliminar elementos de la tabla.
\end{itemize}


\section{Actividad 2}

En esta actividad, el objetivo sigue siendo el mismo que en la actividad anterior, pero en este caso el robot cuenta con un sensor que le permite reconocer si hay o no obstáculos en cierta cantidad de celdas hacia las cuatro direcciones cardinales (arriba, abajo, izquierda, derecha). El robot se desplaza en un mapa representado por una matriz de dimensiones \(N \times M\) que almacena elementos de tipo \texttt{char} y debe llegar a un destino específico desde una posición inicial, evitando obstáculos y utilizando el sensor para obtener información sobre su entorno e intentando optimizar el uso del mismo, dado que se considera costoso.

\subsection{Descripción del Algoritmo}
\begin{problem}{Algoritmo}
    El algoritmo para la navegación del robot con sensor sigue los siguientes pasos:

    \begin{enumerate}
        \item \textbf{Paso 0:} En este momento, el robot no cuenta con nada de información, por lo que usa el sensor para detectar obstáculos y/o casillas libres a su alrededor.
        
        \item \textbf{Paso 1:} El robot siempre conoce su posición inicial y la posición destino. Entonces, utilizando una implementación basada en el algoritmo A*, calcula la ruta más corta hacia el destino asumiendo que las casillas desconocidas están libres pero tienen sumado un costo fijo que representa el costo de usar el sensor.

        \item \textbf{Paso 2:} Una vez que se construye el camino óptimo, el robot se mueve a lo largo de él mientras las casillas sean conocidas. Si la siguiente casilla del camino es desconocida, utiliza el sensor para asegurarse de que no hay un obstáculo y vuelve al paso 1, recalculando la ruta con la nueva información.
    \end{enumerate}

    Este enfoque permite al robot explorar el entorno de manera más eficiente y segura, utilizando la información del sensor para evitar obstáculos y encontrar un camino que, aunque quizás no sea el más corto, intentará usar la menor cantidad de veces posible el sensor.
\end{problem}
\pagebreak
\subsection{Estructuras de Datos Utilizadas}

\begin{lstlisting}[language=C]
typedef struct {
    Punto *pos;
    Punto *dest;
    Mapa *mapa;
    DGList camino;
} _Robot;
typedef _Robot *Robot;

typedef struct {
    Punto padre;
    int costo;
} CeldaInfo;
\end{lstlisting}

\textbf{Estructuras \texttt{Robot} y \texttt{CeldaInfo}:}
Para la implementación del algoritmo, estas son las estructuras centrales que representan información clave al momento de calcular la ruta óptima y que el robot se mueva a lo largo de ella.

\subsubsection{Robot}
\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{Punto \texttt{*pos} y \texttt{*dest}:} Representan la posición actual y la posición destino del robot, respectivamente, al igual que en la actividad 1.

    \item \textbf{Mapa \texttt{*mapa}:} Representa la información que tiene el robot sobre el mapa actual. Es una matriz de \texttt{char} de dimensiones \(N \times M\) donde cada celda puede tener uno de los siguientes valores:
        \begin{enumerate}
            \item \texttt{`?'}: Celda desconocida.
            \item \texttt{`.'}: Celda libre.
            \item \texttt{`\#'}: Celda con obstáculo.
        \end{enumerate}

    \item \textbf{\texttt{DGList camino}:} Una lista doblemente enlazada que almacena el camino que el robot debería seguir para llegar al destino. Cuando el robot no tiene suficiente información sobre el mapa y encuentra una celda desconocida en el camino hacia el destino, usa el sensor, agrega la nueva información al mapa, y recalcula el camino más corto.
\end{itemize}

\subsubsection{CeldaInfo}
\textbf{Descripción de los campos:}
\begin{itemize}
    \item \textbf{\texttt{Punto padre}:} Un punto que representa el nodo padre de una celda en la matriz. Esto permite seguir el camino de regreso desde el destino hasta la posición inicial una vez que el camino más corto ha sido calculado. Cuando se crea una instancia de \texttt{CeldaInfo}, se inicializa el campo \texttt{padre} al punto (-1, -1), indicando la ausencia de un nodo padre.

    \item \textbf{\texttt{int costo}:} Representa el costo acumulado de llegar a esta celda desde la posición inicial del robot durante el cálculo de la ruta. Este campo es clave para aplicar el algoritmo A*, donde se minimiza este costo para encontrar el camino más corto.
\end{itemize}

\section{Cálculo de Costos y Seguimiento de la Ruta}

En esta sección se describe cómo se calculan los costos de las celdas y cómo se sigue el camino calculado en el algoritmo A*.

\textbf{Cálculo de Costos:}
Para cada celda \( c_{i,j} \) en la matriz del mapa, se define un costo \( f(i,j) \) que consiste en la suma del costo acumulado \( g(i,j) \) de llegar a esa celda desde la posición inicial, y una heurística \( h(i,j) \) que estima el costo de llegar desde \( c_{i,j} \) hasta el destino. Formalmente:

\[
f(i,j) = g(i,j) + h(i,j)
\]

\textbf{Seguimiento de la Ruta:}
Una vez que se ha calculado el camino más corto, el robot comienza a moverse a lo largo de este camino. Si el robot encuentra una celda desconocida, utiliza el sensor para obtener información y luego recalcula el camino desde su posición actual hasta el destino con la nueva información disponible.

Si el sensor detecta un obstáculo, el robot recalcula el camino evitando la celda recién descubierta. Si no hay un camino alternativo, el robot retrocede hasta una posición desde la que pueda intentar un nuevo camino.

\end{document}
